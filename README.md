ASSUMPTIONS:

1. Any version of Java can be used (Java 8).
2. Instruction record table presented in the assignment is an analog of a DB table - which means that:
    - the data model has been defined 
    - the data is stored permanently in a data storage and can be requested by our report service at any point of time
    - the data has been validated
3. Settlement date defines when the client wished the payment to be settled with respect to Instruction date - which means:
    - if for some reason the Instruction date is ahead of Settlement date (in other words - instruction has been received and processed by our system with a delay) we have to shift the Settlement date to the Instruction date.
4. Assignment doesn't define strictly how report's data has to be represented - which means:
    - the data can be represented by several tables
    - can be sorted in a preferred way
    - default values can be flexible. 
    For example:
        - if for some entities we don’t have instructions with type SELL - we don’t display any rank for that entity in the report.
        - if we requested a report with total amounts for a specific period of time - we don’t display records for those dates which have no instructions settled.
        - if we requested a report with total amounts for a specific period of time - we display total amount as 0 for  instruction types which didn't take place for a date.
    In real life I would request more details about the report before proceeding with the task.


IMPLEMENTATION NOTES:


CSVAccessor is an abstract class which allows to get access to a CSV file to read any data from there:
- uses apache library to read CSV records from a CSV file
- can be configured through CSVAccessorConfig class
- provides an interface for parsing CSV records into a generic type

CSVAccessorConfig - allows to configure data accessor (data source location ...)



Instruction represents an instruction in the project:
- doesn't carry any logic
- is immutable in our case (can be changed if required)


InstructionType is an enum which represents supported types of our instructions:
- allows to iterate through its values
- can be extended with custom fields (f.e. name)



InstructionCSVDAO is a data access class for instructions:
- extends CSVAccessor and implements its interface for parsing instructions
- sets CSVAccessorConfig for CSVAccessor

InstructionCSVFields describes fields of a CSV file record for an instruction (is a part of InstructionCSVDAO)

InstructionCSVParser is responsible for data matching from a CSV record to an instruction (is a part of InstructionCSVDAO)
  - contains some logic responsible for data validation which can be omitted - 
  assuming that CSV file stored in the system already has valid data.



ReportService is responsible for generating a report:
  - formats and organises the data by grouping
  - uses other services and utilities for calculations
  - uses an injected data access object to read instructions
  - doesn't contain any logic which determines how the data will be used next (see: ReportTablePrinter)

ReportTablePrinter is a part of report service package:
  - responsible for presenting data generated by ReportService class to a consumer (sorting, setting default values, formatting ...)
  - uses other utils to print the data to a console



SettlementDateCalculator is responsible for calculation of an instruction's settlement date:
  - list of currencies which define shifted weekends can be extended later

ValueCalculator is responsible for calculation of instructions' total financial value:
  - can be used for calculation of an individual instruction's value too



InstructionProcessor is a main class:
- has a section which defines all dependencies used by the service. It has to be replaced by a DI framework (Google Guice ...) for more complex projects.
- most of the dependencies are singletons (their instances can be reused in the code), generally a simple static class would be used for such a small project. Assuming that this is a part of a bigger project. In that case we would need a better way to manage dependencies.
- settings for CSVAccessorConfig dependency can be stored in a config file of our project instead of being hardcoded.
