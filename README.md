# instruction-processor

ASSUMPTIONS:

1. Any version of Java can be used. I decided to use Java 8.
2. Instruction record table presented in the assignment is an analog of a DB table - which means that:
    - the data model has been defined already 
    - the data is stored permanently in a data storage and can be read by request from our report service at any point of time
    - the data has been validated already before saving it into the storage
3. Settlement date defines when the client wished the payment to be settled with respect to the instruction’s date - which means:
    - if for some reason the instruction’s date is ahead of it’s settlement date (in other words - instruction has been received and processed by our system with a delay) we have to shift the settlement date to the instruction’s date.
4. Report requrenments of the assignment don’t define how exactly data has to be structured - which means:
    - the data can be represented by several tables and sorted by any column.
    - default values can be flexible. For example:
        - if for some entities we don’t have instructions with type SELL - we don’t define any ranks for that entity and don't display them in the report.
        - if we requested a report with total amounts for a specific period of time - we don’t display records for those dates which have no instructions.
        - if we requested a report with total amounts for a specific period of time - we display total amount as 0 for those instruction types which didn't take place for a specific date.
    - in real life I would request more details about the report before proceeding with the task.


IMPLEMENTATION NOTES:


CSVAccessor is an abstract class which allows to get access to a CSV file to read any data from there:
- uses apache library to read CSV records from a CSV file
- can be configured through CSVAccessorConfig class
- provides an interface for parsing CSV records into a generic type

CSVAccessorConfig - allows to configure data accessor (data source location ...)



Instruction represents an instruction in the project:
- doesn't carry any logic
- is immutable in our case (can be changed if required)


InstructionType is an enum which represents supported types of our instructions:
- allows to iterate through its values
- can be extended with custom fields (f.e. name)



InstructionCSVDAO is a data access class for instructions:
- extends CSVAccessor and implements its interface for parsing instructions
- sets CSVAccessorConfig for CSVAccessor

InstructionCSVFields describes fields of a CSV file record for an instruction (is a part of InstructionCSVDAO)

InstructionCSVParser is responsible for data matching from a CSV record to an instruction (is a part of InstructionCSVDAO)
  - contains some logic responsible for data validation which can be omitted - 
  assuming that CSV file stored in the system already has valid data.



ReportService is responsible for generating a report:
  - formats and organises the data by grouping
  - uses other services and utilities for calculations
  - uses an injected data access object to read instructions
  - doesn't contain any logic which determines how the data will be used next (see: ReportTablePrinter)

ReportTablePrinter is a part of report service package:
  - responsible for presenting data generated by ReportService class to a consumer (sorting, setting default values, formatting ...)
  - uses other utils to print the data to a console



SettlementDateCalculator is responsible for calculation of an instruction's settlement date:
  - list of currencies which define shifted weekends can be extended later

ValueCalculator is responsible for calculation of instructions' total financial value:
  - can be used for calculation of an individual instruction's value too



InstructionProcessor is a main class:
- has a section which defines all dependencies used by the service. It has to be replaced by a DI framework (Google Guice ...) for more complex projects.
- most of the dependecies are singletons (their instances can be reused in the code), generally a simple static class would be used for such a small project. Assuming that this is a part of a bigger project. In that case we would need a better way to manage dependencies.
- settings for CSVAccessorConfig dependency can be stored in a config file of our project instead of being hardcoded.




